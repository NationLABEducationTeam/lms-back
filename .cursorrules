# Instructions

During you interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again. 

You should also use the `.cursorrules` file as a scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

# Tools

Note all the tools are in python. So in the case you need to do batch processing, you can always consult the python files and write your own script.

## Screenshot Verification
The screenshot verification workflow allows you to capture screenshots of web pages and verify their appearance using LLMs. The following tools are available:

1. Screenshot Capture:
```bash
venv/bin/python tools/screenshot_utils.py URL [--output OUTPUT] [--width WIDTH] [--height HEIGHT]
```

2. LLM Verification with Images:
```bash
venv/bin/python tools/llm_api.py --prompt "Your verification question" --provider {openai|anthropic} --image path/to/screenshot.png
```

Example workflow:
```python
from screenshot_utils import take_screenshot_sync
from llm_api import query_llm

# Take a screenshot
screenshot_path = take_screenshot_sync('https://example.com', 'screenshot.png')

# Verify with LLM
response = query_llm(
    "What is the background color and title of this webpage?",
    provider="openai",  # or "anthropic"
    image_path=screenshot_path
)
print(response)
```

## LLM

You always have an LLM at your side to help you with the task. For simple tasks, you could invoke the LLM by running the following command:
```
venv/bin/python ./tools/llm_api.py --prompt "What is the capital of France?" --provider "anthropic"
```

The LLM API supports multiple providers:
- OpenAI (default, model: gpt-4o)
- Azure OpenAI (model: configured via AZURE_OPENAI_MODEL_DEPLOYMENT in .env file, defaults to gpt-4o-ms)
- DeepSeek (model: deepseek-chat)
- Anthropic (model: claude-3-sonnet-20240229)
- Gemini (model: gemini-pro)
- Local LLM (model: Qwen/Qwen2.5-32B-Instruct-AWQ)

But usually it's a better idea to check the content of the file and use the APIs in the `tools/llm_api.py` file to invoke the LLM if needed.

## Web browser

You could use the `tools/web_scraper.py` file to scrape the web.
```
venv/bin/python ./tools/web_scraper.py --max-concurrent 3 URL1 URL2 URL3
```
This will output the content of the web pages.

## Search engine

You could use the `tools/search_engine.py` file to search the web.
```
venv/bin/python ./tools/search_engine.py "your search keywords"
```
This will output the search results in the following format:
```
URL: https://example.com
Title: This is the title of the search result
Snippet: This is a snippet of the search result
```
If needed, you can further use the `web_scraper.py` file to scrape the web page content.

# Lessons

## User Specified Lessons

- You have a python venv in ./venv. Use it.
- Include info useful for debugging in the program output.
- Read the file before you try to edit it.
- Due to Cursor's limit, when you use `git` and `gh` and need to submit a multiline commit message, first write the message in a file, and then use `git commit -F <filename>` or similar command to commit. And then remove the file. Include "[Cursor] " in the commit message and PR title.

## Cursor learned

- For search results, ensure proper handling of different character encodings (UTF-8) for international queries
- Add debug information to stderr while keeping the main output clean in stdout for better pipeline integration
- When using seaborn styles in matplotlib, use 'seaborn-v0_8' instead of 'seaborn' as the style name due to recent seaborn version changes
- Use 'gpt-4o' as the model name for OpenAI's GPT-4 with vision capabilities
- In JWT authentication, the user ID is stored in the `sub` field, not in `id`. Always use `req.user.sub` to get the user ID in route handlers.
- When comparing ID fields between tables, make sure to handle type mismatches with explicit casting (e.g., `item_id::text = sg.item_id::text`)

# Scratchpad

## Project Overview - LMS Backend

### Architecture
- Express.js based Learning Management System backend
- AWS services integration
- Docker containerization

### Core Modules
- Courses management
- Enrollment management
- Student management
- User management
- AI features

### Tech Stack
- Backend: Express.js
- Databases: PostgreSQL, DynamoDB
- Cache: Redis
- Storage: AWS S3
- Auth: JWT
- Logging: Winston, Morgan

### Course Week Management Status

#### S3 Configuration
- Bucket: `nationslablmscoursebucket`
- Region: `ap-northeast-2` (Seoul)
- File Structure:
  ```
  강좌명/
  ├── 1주차/
  │   ├── 강의자료.pdf
  │   ├── 과제.docx
  │   └── 강의영상.mp4
  ├── 2주차/
  └── ...
  ```

#### Implemented Features
- S3 bucket and basic file structure setup
- File listing functionality by week
- File type categorization

#### Pending Features
- Weekly course creation API
- Course material upload API
- Weekly course modification/deletion API
- Integration between course materials and course DB

#### Supported File Types
- Documents: pdf, doc, docx
- Presentations: ppt, pptx
- Spreadsheets: xls, xlsx
- Media: jpg, jpeg, png, gif, mp4, mp3
- Others: txt, json, zip, rar

#### API Endpoints

##### Implemented Functions
```javascript
// S3 Utility Functions (src/utils/s3.js)
listCourseWeekMaterials(prefix)  // List all week materials for a course
listWeekFiles(weekPrefix)        // List files for specific week
getFileType(fileName)            // Determine file type

// Course Routes (src/routes/courses.js)
GET /courses/test-db             // Test DB connection
GET /courses/public             // Get all published courses
GET /courses                    // Get all courses
GET /courses/:courseId          // Get specific course
POST /courses/:courseId/enroll  // Enroll in course
GET /courses/my/progress        // Get student's course progress
POST /courses                   // Create new course
```

##### Required New APIs
```javascript
// Week Management
POST /courses/:courseId/weeks
{
    weekNumber: number,
    title: string,
    description: string,
    startDate: Date,
    endDate: Date
}

PUT /courses/:courseId/weeks/:weekNumber
DELETE /courses/:courseId/weeks/:weekNumber
GET /courses/:courseId/weeks
GET /courses/:courseId/weeks/:weekNumber

// Materials Management
POST /courses/:courseId/weeks/:weekNumber/materials
{
    files: File[],
    type: string,
    title: string,
    description: string
}

PUT /courses/:courseId/weeks/:weekNumber/materials/:materialId
DELETE /courses/:courseId/weeks/:weekNumber/materials/:materialId
GET /courses/:courseId/weeks/:weekNumber/materials
GET /courses/:courseId/weeks/:weekNumber/materials/:materialId
```

## 현재 작업: 비디오 타임마크 기능 구현

### 구현 계획

1. DynamoDB 테이블 구조
- 테이블명: LMSVOD_TimeMarks
- 파티션 키: id (String)
- 정렬 키: timestamp (String)
- 추가 필드:
  - userId (String)
  - courseId (String)
  - videoId (String)
  - content (String)
  - createdAt (String)
  - updatedAt (String)

2. 구현할 API 엔드포인트
[X] POST /api/timemarks - 타임마크 생성
[X] GET /api/timemarks/{courseId}/{videoId} - 타임마크 목록 조회
[X] PUT /api/timemarks/{timemarkId} - 타임마크 수정
[X] DELETE /api/timemarks/{timemarkId} - 타임마크 삭제

3. 구현 순서
[X] 1. src/routes/timemarks.js 파일 생성
[X] 2. DynamoDB 관련 유틸리티 함수 구현 (src/utils/dynamodb.js)
[X] 3. 타임마크 생성 API 구현
[X] 4. 타임마크 조회 API 구현
[X] 5. 타임마크 수정 API 구현
[X] 6. 타임마크 삭제 API 구현
[X] 7. 인증 미들웨어 연동
[ ] 8. API 테스트

### 주의사항
- 사용자 인증 확인 ✅
- 본인 작성 타임마크만 수정/삭제 가능 ✅
- 수강 중인 강의에만 타임마크 생성 가능 ✅
- 영상 길이 초과 시간 체크 (추후 구현 필요)

### 다음 단계
1. API 테스트 진행
2. 영상 길이 초과 시간 체크 기능 구현
3. 프론트엔드 연동 준비

# 성적 관리 시스템 (Grade Schema) - 2024-05-07 업데이트

## 테이블 구조

### 실제 데이터베이스 테이블

#### 1. grade_schema.grade_items
```sql
CREATE TABLE grade_schema.grade_items (
    item_id integer NOT NULL PRIMARY KEY,
    course_id text NOT NULL REFERENCES course_schema.courses(id),
    item_type varchar(20) NOT NULL,
    item_name varchar(100) NOT NULL,
    item_order integer NOT NULL,
    due_date date
);
```

#### 2. grade_schema.student_grades
```sql
CREATE TABLE grade_schema.student_grades (
    grade_id integer NOT NULL PRIMARY KEY,
    enrollment_id uuid NOT NULL REFERENCES enrollment_schema.enrollments(id),
    item_id bigint NOT NULL REFERENCES grade_schema.grade_items(item_id),
    score numeric(10,5) NOT NULL,
    is_completed boolean NOT NULL,
    submission_date timestamp without time zone,
    submission_data jsonb,
    feedback text,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);
```

#### 3. course_schema.courses (성적 관련 컬럼)
```sql
ALTER TABLE course_schema.courses
ADD COLUMN attendance_weight integer DEFAULT 20,
ADD COLUMN assignment_weight integer DEFAULT 50,
ADD COLUMN exam_weight integer DEFAULT 30,
ADD COLUMN weeks_count integer DEFAULT 16,
ADD COLUMN assignment_count integer DEFAULT 1,
ADD COLUMN exam_count integer DEFAULT 1;
```

### 코드에서 참조되지만 실제로 존재하지 않는 테이블
- attendance_records
- final_grades
- course_grade_rules

## 성적 관리 메커니즘

### 1. 강좌 생성 시
- courses 테이블에 기본 가중치 설정 (attendance_weight, assignment_weight, exam_weight)
- weeks_count, assignment_count, exam_count 값 설정

### 2. 학생 등록 시
- grade_items 테이블의 모든 평가 항목에 대해 student_grades 레코드 생성 (초기 점수: 0)

### 3. 성적 평가 프로세스
- 출석: 코드에서는 attendance_records 참조하나 실제 테이블 없음
- 과제: grade_items(ASSIGNMENT 타입)과 student_grades 연동
- 시험: grade_items(EXAM 타입)과 student_grades 연동

### 4. 최종 성적 계산
- 각 타입별 평균 점수 계산
- 가중치 적용
- enrollments.final_grade에 저장 가능

## 성적 관리 개선 작업

### 현재 문제점
1. **테이블 불일치**: 코드에서 참조되는 테이블(`attendance_records`, `final_grades`, `course_grade_rules`)이 실제 DB에 없음
2. **비효율적 쿼리**:
   - 동일한 과목/학생 정보를 여러 번 조회
   - 중첩 서브쿼리 사용으로 성능 저하
   - 불필요한 WITH 절과 임시 테이블 사용
3. **출석 기록 관리 시스템 미구현**: 코드는 있으나 관련 테이블이 없음
4. **성적 계산 중복**: 여러 API에서 동일한 계산 로직 중복
5. **트랜잭션 관리 미흡**: 일부 성적 수정 작업 시 트랜잭션 처리 미흡

### 개선 계획

#### 1단계: 누락된 테이블 생성
1. `attendance_records` 테이블 생성:
```sql
CREATE TABLE grade_schema.attendance_records (
    record_id SERIAL PRIMARY KEY,
    student_id VARCHAR(36) NOT NULL REFERENCES auth_schema.users(cognito_user_id),
    course_id TEXT NOT NULL REFERENCES course_schema.courses(id),
    session_type VARCHAR(20) NOT NULL, -- 'LIVE', 'VOD'
    session_id TEXT NOT NULL, -- 강의 세션 ID
    duration_seconds INTEGER NOT NULL DEFAULT 0, -- 학생 참여 시간
    total_duration_seconds INTEGER NOT NULL DEFAULT 0, -- 전체 강의 시간
    attendance_date DATE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(student_id, course_id, session_id)
);
```

2. `final_grades` 테이블 생성:
```sql
CREATE TABLE grade_schema.final_grades (
    id SERIAL PRIMARY KEY,
    student_id VARCHAR(36) NOT NULL REFERENCES auth_schema.users(cognito_user_id),
    course_id TEXT NOT NULL REFERENCES course_schema.courses(id),
    attendance_score NUMERIC(5,2) NOT NULL DEFAULT 0,
    assignment_score NUMERIC(5,2) NOT NULL DEFAULT 0,
    exam_score NUMERIC(5,2) NOT NULL DEFAULT 0,
    total_score NUMERIC(5,2) NOT NULL DEFAULT 0,
    attendance_rate NUMERIC(5,2) NOT NULL DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(student_id, course_id)
);
```

#### 2단계: 성적 계산 쿼리 최적화

1. **`updateFinalGrades` 함수 최적화**:
```javascript
async function updateFinalGrades(client, courseId, studentId) {
    // 단일 쿼리로 필요한 모든 정보 조회
    const result = await client.query(`
        WITH enrollment_info AS (
            SELECT id 
            FROM enrollment_schema.enrollments
            WHERE course_id = $1 AND student_id = $2
            LIMIT 1
        ),
        attendance_info AS (
            SELECT 
                COALESCE(SUM(duration_seconds), 0) as total_attended,
                NULLIF(COALESCE(SUM(total_duration_seconds), 0), 0) as total_required
            FROM grade_schema.attendance_records
            WHERE course_id = $1 AND student_id = $2
        ),
        assignment_score AS (
            SELECT COALESCE(AVG(sg.score), 0) as avg_score
            FROM grade_schema.grade_items gi
            JOIN enrollment_info ei ON true
            LEFT JOIN grade_schema.student_grades sg 
                ON gi.item_id = sg.item_id AND sg.enrollment_id = ei.id
            WHERE gi.course_id = $1 AND gi.item_type = 'ASSIGNMENT'
        ),
        exam_score AS (
            SELECT COALESCE(AVG(sg.score), 0) as avg_score
            FROM grade_schema.grade_items gi
            JOIN enrollment_info ei ON true
            LEFT JOIN grade_schema.student_grades sg 
                ON gi.item_id = sg.item_id AND sg.enrollment_id = ei.id
            WHERE gi.course_id = $1 AND gi.item_type = 'EXAM'
        ),
        course_info AS (
            SELECT
                attendance_weight,
                assignment_weight,
                exam_weight
            FROM course_schema.courses
            WHERE id = $1
        )
        SELECT
            ei.id as enrollment_id,
            c.attendance_weight,
            c.assignment_weight,
            c.exam_weight,
            CASE WHEN a.total_required > 0 
                THEN (a.total_attended::float / a.total_required) * 100 
                ELSE 0 
            END as attendance_rate,
            asg.avg_score as assignment_score,
            exm.avg_score as exam_score
        FROM enrollment_info ei
        CROSS JOIN course_info c
        CROSS JOIN attendance_info a
        CROSS JOIN assignment_score asg
        CROSS JOIN exam_score exm
    `, [courseId, studentId]);

    if (result.rows.length === 0) {
        throw new Error('수강 정보를 찾을 수 없습니다.');
    }

    const gradeInfo = result.rows[0];
    
    // 최종 성적 계산
    const {
        attendance_weight,
        assignment_weight,
        exam_weight,
        attendance_rate,
        assignment_score,
        exam_score
    } = gradeInfo;

    const totalScore = (
        (attendance_rate * attendance_weight / 100) +
        (assignment_score * assignment_weight / 100) +
        (exam_score * exam_weight / 100)
    );

    // 최종 성적 업데이트 (enrollments 테이블에도 저장)
    // final_grades 테이블이 아직 없으므로 enrollments.final_grade 사용
    await client.query(`
        UPDATE enrollment_schema.enrollments
        SET final_grade = $1
        WHERE course_id = $2 AND student_id = $3
    `, [totalScore, courseId, studentId]);
    
    return {
        attendance_rate,
        assignment_score,
        exam_score,
        total_score: totalScore
    };
}
```

2. **학생 성적 조회 API 최적화**:
```javascript
router.get('/:courseId/my-grades', verifyToken, async (req, res) => {
    const client = await masterPool.connect();
    try {
        const studentId = req.user.id;
        const { courseId } = req.params;
        
        // 단일 쿼리로 필요한 모든 정보 조회
        const result = await client.query(`
            WITH enrollment_info AS (
                SELECT id
                FROM enrollment_schema.enrollments
                WHERE course_id = $1 AND student_id = $2
                LIMIT 1
            ),
            attendance_rate AS (
                SELECT 
                    CASE WHEN SUM(total_duration_seconds) > 0 
                        THEN (SUM(duration_seconds)::float / SUM(total_duration_seconds)) * 100 
                        ELSE 0 
                    END as rate
                FROM grade_schema.attendance_records
                WHERE course_id = $1 AND student_id = $2
            ),
            assignments AS (
                SELECT json_agg(
                    json_build_object(
                        'id', gi.item_id,
                        'title', gi.item_name,
                        'dueDate', gi.due_date,
                        'score', COALESCE(sg.score, 0),
                        'isCompleted', COALESCE(sg.is_completed, false)
                    )
                ) as items,
                COALESCE(AVG(sg.score), 0) as avg_score
                FROM grade_schema.grade_items gi
                JOIN enrollment_info ei ON true
                LEFT JOIN grade_schema.student_grades sg 
                    ON gi.item_id = sg.item_id AND sg.enrollment_id = ei.id
                WHERE gi.course_id = $1 AND gi.item_type = 'ASSIGNMENT'
            ),
            exams AS (
                SELECT json_agg(
                    json_build_object(
                        'id', gi.item_id,
                        'title', gi.item_name,
                        'dueDate', gi.due_date,
                        'score', COALESCE(sg.score, 0),
                        'isCompleted', COALESCE(sg.is_completed, false)
                    )
                ) as items,
                COALESCE(AVG(sg.score), 0) as avg_score
                FROM grade_schema.grade_items gi
                JOIN enrollment_info ei ON true
                LEFT JOIN grade_schema.student_grades sg 
                    ON gi.item_id = sg.item_id AND sg.enrollment_id = ei.id
                WHERE gi.course_id = $1 AND gi.item_type = 'EXAM'
            )
            SELECT
                c.title as course_title,
                c.attendance_weight,
                c.assignment_weight,
                c.exam_weight,
                ar.rate as attendance_rate,
                a.items as assignments,
                a.avg_score as assignment_score,
                e.items as exams,
                e.avg_score as exam_score
            FROM course_schema.courses c
            CROSS JOIN attendance_rate ar
            CROSS JOIN assignments a
            CROSS JOIN exams e
            WHERE c.id = $1
        `, [courseId, studentId]);

        if (result.rows.length === 0) {
            return res.status(404).json({
                success: false,
                message: "과목 정보를 찾을 수 없습니다."
            });
        }

        const gradeInfo = result.rows[0];
        const attendanceRate = parseFloat(gradeInfo.attendance_rate.toFixed(1));
        
        res.json({
            success: true,
            data: {
                course: {
                    title: gradeInfo.course_title,
                    attendance_weight: gradeInfo.attendance_weight,
                    assignment_weight: gradeInfo.assignment_weight,
                    exam_weight: gradeInfo.exam_weight
                },
                grades: {
                    attendance: {
                        rate: attendanceRate,
                        score: parseFloat(((attendanceRate * gradeInfo.attendance_weight) / 100).toFixed(1))
                    },
                    assignments: gradeInfo.assignments || [],
                    exams: gradeInfo.exams || [],
                    assignmentScore: parseFloat(gradeInfo.assignment_score.toFixed(1)),
                    examScore: parseFloat(gradeInfo.exam_score.toFixed(1))
                }
            }
        });
    } catch (error) {
        console.error('Error fetching grades:', error);
        res.status(500).json({
            success: false,
            message: "성적 조회 중 오류가 발생했습니다.",
            error: error.message
        });
    } finally {
        client.release();
    }
});
```

#### 3단계: 기타 개선 사항

1. **성적 히스토리 관리**:
```sql
CREATE TABLE grade_schema.grade_history (
    id SERIAL PRIMARY KEY,
    grade_id INTEGER NOT NULL REFERENCES grade_schema.student_grades(grade_id),
    previous_score NUMERIC(10,5) NOT NULL,
    new_score NUMERIC(10,5) NOT NULL,
    modified_by VARCHAR(36) NOT NULL REFERENCES auth_schema.users(cognito_user_id),
    reason TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
```

2. **출석 기록 관리 최적화**:
   - VOD 시청 시간 자동 기록
   - 실시간 출석 체크 시스템 개선
   - 임계값 설정 (예: 80% 이상 시청 시 출석 인정)

3. **성적 통계 기능**:
```javascript
router.get('/statistics/:courseId', verifyToken, requireRole(['ADMIN', 'INSTRUCTOR']), async (req, res) => {
    const client = await masterPool.connect();
    try {
        const { courseId } = req.params;
        
        const result = await client.query(`
            WITH grade_stats AS (
                SELECT
                    gi.item_id,
                    gi.item_name,
                    gi.item_type,
                    COUNT(sg.grade_id) as total_students,
                    COALESCE(AVG(sg.score), 0) as average_score,
                    MIN(sg.score) as min_score,
                    MAX(sg.score) as max_score,
                    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY sg.score) as median_score,
                    COUNT(CASE WHEN sg.is_completed THEN 1 END) as completed_count
                FROM grade_schema.grade_items gi
                LEFT JOIN grade_schema.student_grades sg ON gi.item_id = sg.item_id
                WHERE gi.course_id = $1
                GROUP BY gi.item_id, gi.item_name, gi.item_type
            )
            SELECT
                c.title as course_title,
                json_agg(
                    json_build_object(
                        'id', gs.item_id,
                        'name', gs.item_name,
                        'type', gs.item_type,
                        'totalStudents', gs.total_students,
                        'averageScore', gs.average_score,
                        'minScore', gs.min_score,
                        'maxScore', gs.max_score,
                        'medianScore', gs.median_score,
                        'completedCount', gs.completed_count,
                        'completionRate', CASE WHEN gs.total_students > 0 
                            THEN (gs.completed_count::float / gs.total_students) * 100 
                            ELSE 0 
                        END
                    )
                ) as items_statistics
            FROM course_schema.courses c
            LEFT JOIN grade_stats gs ON true
            WHERE c.id = $1
            GROUP BY c.id, c.title
        `, [courseId]);
        
        res.json({
            success: true,
            data: result.rows[0]
        });
    } catch (error) {
        console.error('Error fetching grade statistics:', error);
        res.status(500).json({
            success: false,
            message: "성적 통계 조회 중 오류가 발생했습니다.",
            error: error.message
        });
    } finally {
        client.release();
    }
});
```

4. **성적 엑셀 출력 기능**:
```javascript
router.get('/export/:courseId', verifyToken, requireRole(['ADMIN', 'INSTRUCTOR']), async (req, res) => {
    const client = await masterPool.connect();
    try {
        const { courseId } = req.params;
        
        // 성적 데이터 조회
        const result = await client.query(`
            WITH students AS (
                SELECT 
                    e.id as enrollment_id,
                    u.cognito_user_id as student_id,
                    u.name as student_name,
                    u.email
                FROM enrollment_schema.enrollments e
                JOIN auth_schema.users u ON e.student_id = u.cognito_user_id
                WHERE e.course_id = $1 AND e.status = 'ACTIVE'
            ),
            attendance_rates AS (
                SELECT 
                    s.student_id,
                    CASE WHEN SUM(ar.total_duration_seconds) > 0 
                        THEN (SUM(ar.duration_seconds)::float / SUM(ar.total_duration_seconds)) * 100 
                        ELSE 0 
                    END as rate
                FROM students s
                LEFT JOIN grade_schema.attendance_records ar 
                    ON s.student_id = ar.student_id AND ar.course_id = $1
                GROUP BY s.student_id
            ),
            grades AS (
                SELECT
                    s.student_id,
                    gi.item_id,
                    gi.item_name,
                    gi.item_type,
                    COALESCE(sg.score, 0) as score
                FROM students s
                CROSS JOIN grade_schema.grade_items gi
                LEFT JOIN grade_schema.student_grades sg 
                    ON gi.item_id = sg.item_id AND sg.enrollment_id = s.enrollment_id
                WHERE gi.course_id = $1
            )
            SELECT
                s.student_id,
                s.student_name,
                s.email,
                ar.rate as attendance_rate,
                c.attendance_weight,
                c.assignment_weight,
                c.exam_weight,
                json_object_agg(g.item_id, g.score) as item_scores,
                COALESCE(AVG(CASE WHEN g.item_type = 'ASSIGNMENT' THEN g.score END), 0) as avg_assignment,
                COALESCE(AVG(CASE WHEN g.item_type = 'EXAM' THEN g.score END), 0) as avg_exam,
                (
                    (ar.rate * c.attendance_weight / 100) +
                    (COALESCE(AVG(CASE WHEN g.item_type = 'ASSIGNMENT' THEN g.score END), 0) * c.assignment_weight / 100) +
                    (COALESCE(AVG(CASE WHEN g.item_type = 'EXAM' THEN g.score END), 0) * c.exam_weight / 100)
                ) as total_score
            FROM students s
            JOIN course_schema.courses c ON c.id = $1
            JOIN attendance_rates ar ON s.student_id = ar.student_id
            LEFT JOIN grades g ON s.student_id = g.student_id
            GROUP BY s.student_id, s.student_name, s.email, ar.rate, c.attendance_weight, c.assignment_weight, c.exam_weight
            ORDER BY s.student_name
        `, [courseId]);
        
        // 엑셀 파일 생성 로직
        // ...
        
        res.json({
            success: true,
            data: result.rows
        });
    } catch (error) {
        console.error('Error exporting grades:', error);
        res.status(500).json({
            success: false,
            message: "성적 내보내기 중 오류가 발생했습니다.",
            error: error.message
        });
    } finally {
        client.release();
    }
});
```

### 개선 작업 체크리스트
[X] 1. 누락된 테이블 생성 (attendance_records, final_grades)
[X] 2. 비효율적 쿼리 최적화 (updateFinalGrades 함수 개선)
[X] 3. 학생 성적 조회 API 최적화
[X] 4. 성적 히스토리 관리 기능 구현
[X] 5. 성적 통계 기능 구현
[X] 6. 성적 엑셀 출력 기능 구현
[X] 7. 트랜잭션 관리 강화

### 구현된 개선 사항 요약
1. **데이터베이스 테이블 생성**:
   - `attendance_records`: 출석 기록 관리 테이블
   - `final_grades`: 최종 성적 저장 테이블
   - `grade_history`: 성적 변경 히스토리 테이블

2. **쿼리 최적화**:
   - 여러 개의 쿼리를 하나의 복합 쿼리로 통합
   - WITH 절을 사용한 효율적인 CTE 구조
   - 불필요한 중복 조회 제거

3. **기능 모듈화**:
   - `grade-calculator.js`: 성적 계산 관련 함수 모듈화
   - 코드 중복 제거 및 일관성 유지

4. **새로운 기능 추가**:
   - 성적 통계 API: 성적 분포 및 통계 정보 제공
   - 성적 내보내기 API: 과목별 전체 학생 성적 데이터 제공
   - 성적 변경 히스토리: 점수 변경 기록 및 추적

5. **데이터 안정성 강화**:
   - 트랜잭션 처리 개선
   - 에러 핸들링 강화
   - 트리거를 통한 자동화된 데이터 일관성 유지

### 마이그레이션 실행 방법
```bash
node src/db/migrations/run-improvements.js
```

### 후속 작업
1. 프론트엔드 인터페이스 업데이트
2. 성적 API 통합 테스트
3. 성적 관리 시스템 사용자 메뉴얼 작성

# 관리자용 과제 관리 시스템 (2024-05-17 추가)

## 구현된 API 엔드포인트

### 1. 특정 과목의 모든 과제 목록 조회
- 엔드포인트: `GET /api/v1/admin/assignments/course/:courseId`
- 기능: 관리자/교수가 특정 과목의 모든 과제 목록과 제출 현황 통계를 조회
- 응답: 과제 ID, 이름, 마감일, 총 학생 수, 제출 수, 완료 제출 수, 평균 점수 등

### 2. 특정 과제의 모든 학생 제출 현황 조회
- 엔드포인트: `GET /api/v1/admin/assignments/:assignmentId/submissions`
- 기능: 관리자/교수가 특정 과제에 대한 모든 학생의 제출 현황을 조회
- 응답: 학생 정보(이름, 이메일), 제출 여부, 점수, 제출 시간, 지연 여부 등

### 3. 특정 학생의 특정 과제 제출물 상세 조회
- 엔드포인트: `GET /api/v1/admin/assignments/submission/:submissionId`
- 기능: 관리자/교수가 특정 학생이 제출한 과제의 상세 내용을 조회
- 응답: 제출물 세부 정보, 제출 파일 목록, 학생 정보 등

### 4. 제출된 파일 다운로드 URL 생성
- 엔드포인트: `GET /api/v1/admin/assignments/file/:fileKey/download-url`
- 기능: 관리자/교수가 학생이 제출한 파일을 다운로드하기 위한 URL 생성
- 응답: 파일 다운로드 URL (1시간 유효)

### 5. 과제 채점 및 피드백 제공
- 엔드포인트: `PUT /api/v1/admin/assignments/submission/:submissionId/grade`
- 기능: 관리자/교수가 학생이 제출한 과제에 점수 부여 및 피드백 제공
- 요청 본문: 점수(score), 피드백(feedback)
- 트랜잭션 처리: 점수 변경 히스토리 기록 및 최종 성적 자동 업데이트

## 주요 특징
- 사용자 인증 및 역할 기반 접근 제어(RBAC) 적용
- 상세한 제출 상태 정보 제공 (제출 여부, 지연 여부, 피드백 존재 여부 등)
- 트랜잭션 처리를 통한 데이터 일관성 보장
- 성적 변경 히스토리 기록을 통한 감사 추적
- S3 파일 관리 연동